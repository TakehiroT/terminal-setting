# Gitワークフロー

## Conventional Commits

### フォーマット

```
<type>(<scope>): <subject>

<body>

<footer>
```

### Type（必須）

- **feat**: 新機能
- **fix**: バグ修正
- **refactor**: リファクタリング（機能変更なし）
- **docs**: ドキュメントのみの変更
- **test**: テストの追加・修正
- **chore**: ビルドプロセス、ツール設定など
- **style**: コードスタイル修正（空白、フォーマット）
- **perf**: パフォーマンス改善
- **ci**: CI設定の変更
- **revert**: 過去のコミットの取り消し

### Scope（オプション）

対象範囲を示す（例: `api`, `ui`, `auth`, `database`）

### Subject（必須）

- 50文字以内を推奨
- 命令形で記述（「追加する」ではなく「追加」）
- 末尾にピリオド不要
- 日本語または英語で明確に

### 例

```bash
# 新機能
feat(auth): JWT認証機能を追加

# バグ修正
fix(api): ユーザー検索で重複結果が返る問題を修正

# リファクタリング
refactor(database): クエリビルダーをクラス化

# ドキュメント
docs: READMEにセットアップ手順を追加

# テスト
test(utils): 日付フォーマット関数のテストを追加

# Scopeなし
chore: 依存関係を最新版に更新
```

## コミットの原則

### 1コミット1変更

- **論理的な単位**: 1つのコミットは1つの変更のみ
- **アトミック性**: そのコミット単体で意味を持つ
- **レビューしやすい**: 変更内容が明確

```bash
# Good: 機能ごとに分割
git commit -m "feat(api): ユーザー登録APIを追加"
git commit -m "test(api): ユーザー登録APIのテストを追加"

# Bad: 複数の変更を混在
git commit -m "APIとテストと修正とリファクタリング"
```

### コミットサイズ

- **小さく頻繁に**: 大きなコミットより小さなコミットを複数
- **目安**: 変更ファイル10個以内、差分200行以内
- **レビュアブル**: 人間が理解できるサイズ

## ブランチ戦略

### ブランチ命名規則

```
<type>/<issue-number>-<short-description>
```

例:
- `feat/123-user-authentication`
- `fix/456-login-error`
- `refactor/789-api-structure`

### メインブランチ

- **main/master**: 常にデプロイ可能な状態
- **develop**: 開発用の統合ブランチ（プロジェクトによる）

### フィーチャーブランチ

- mainから分岐
- 作業完了後にPRでマージ
- マージ後は削除

## プルリクエスト（PR）

### PRは小さく保つ

- **差分300行以内を推奨**: レビューしやすいサイズ
- **1PR1機能**: 複数の機能を混ぜない
- **早めに出す**: Draft PRで早期フィードバック

### PRテンプレート

```markdown
## 概要
<!-- 何を変更したか -->

## 変更内容
- [ ] 新機能の追加
- [ ] バグ修正
- [ ] リファクタリング

## テスト
- [ ] ユニットテストを追加
- [ ] 既存テストが全てパス
- [ ] 手動テストを実施

## チェックリスト
- [ ] コーディング規約に準拠
- [ ] ドキュメントを更新
- [ ] 破壊的変更の有無を確認
```

### PRのレビュー

- **建設的なフィードバック**: 批判ではなく改善提案
- **コード品質**: 可読性、保守性、パフォーマンス
- **テストカバレッジ**: 適切なテストが含まれているか
- **ドキュメント**: 必要に応じて更新されているか

## マージ戦略

### Squash and Merge（推奨）

- PRの複数コミットを1つにまとめる
- 履歴がクリーンになる
- メインブランチのコミットがConventional Commitsに準拠

### Merge Commit

- PRの全コミット履歴を保持
- 詳細な変更履歴が必要な場合

### Rebase and Merge

- 線形な履歴を保つ
- コンフリクト解決が複雑になる可能性

## 禁止事項

- **mainへの直接push**: 必ずPRを経由
- **force push to main**: 他の人の作業を破壊する
- **大量のファイルを1コミット**: 分割してコミット
- **意味のないコミットメッセージ**: 「修正」「update」など

## 便利なGitコマンド

```bash
# 直前のコミットメッセージを修正
git commit --amend

# ステージングされた変更を確認
git diff --staged

# コミット履歴を整理（push前のみ）
git rebase -i HEAD~3

# 特定のファイルのみステージング
git add -p

# 変更を一時退避
git stash
git stash pop
```

## コミット前チェックリスト

- [ ] テストが全てパス
- [ ] Lintエラーなし
- [ ] 不要なconsole.log削除
- [ ] コミットメッセージがConventional Commits準拠
- [ ] 秘密情報が含まれていない
